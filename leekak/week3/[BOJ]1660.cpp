#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int N;
    cin >> N;
    int arr[120];
    vector<int> arr2;   // 사면체가 가질 수 있는 대포알의 개수
    vector<int> dp (N+1, 1e9); // N을 만들기 위한 최소 덧셈 횟수
    arr[0] = 1;
    for(int i=1; i<120; i++) {
        arr[i] = arr[i-1] + i+1;
    }
    arr2.push_back(arr[0]);
    for(int i=1; i<120; i++) {
        int tmp = arr2[i-1] + arr[i];
        if(tmp > 300000) break;
        arr2.push_back(tmp);
    }

    dp[0]=0;
    for(int i:arr2) {
        for(int j=i; j<=N; j++) {
            dp[j] = min(dp[j], dp[j-i] + 1);
        }
    }

    cout << dp[N];

    return 0;
}

/*
 * arr2는 각 사면체를 만든는 데에 필요한 대포알의 개수를 저장하고 있다.
 * 1. N이 arr2에 있으면 1이다.
 * 2. N이 arr2에 없다면 적절히 쪼개야 한다.
 * 1 1
 * 2 1+1
 * 3 1+2
 * 5 1+4
 * 8 4+4
 * 적절히 더한 수??
 * 그니까 반대로 미리 숫자들을 더해서 만들어 놓자
 *
 * 일단 먼저 해야할 일은 한 개의 사면체에 필요한 대포알의 개수를 구하는 일이다.
 * arr1에 각 층에 필요한 대포알의 수를 저장했고
 * 이걸 이용해서 arr2에 사면체에 필요한 대포알의 개수를 저장했다.
 * 무한히 저장할 필요는 없으니 N의 최대인 300,000이 넘지 않을 때까지만 저장한다.
 * (120번 하면 되더라) 이까진 쉬움...
 * arr2 = [1, 4, 10, 20, 35, 56, 84...]
 *
 * 이제 arr2를 이용해서 N개의 대포알로 만들 수 있는 사면체의 개수를 구하자.
 * 처음에는
 * arr2에는 사면체에 필요한 대포알의 개수가 저장되어 있으므로
 * N보다 작은 수중 가장 대포알의 개수가 많은 곳으로 가서
 * 그 수만큼 빼준 뒤 남은 수에 대해 반복하는 방법(0이될 때 까지)을 생각했다. (그리디)
 * 이렇게 푸니 91이 들어왔을 때 문제가 생긴다.
 * 그리디하게 풀자면 91-84, 7-4, 3-1, 2-1, 1-1 총 5개이다.
 * 하지만 실제 최소 개수는 35와 56 두개를 선택한, 2이다.
 *
 * 그럼 어케 풀어야 하게~?
 * dp다 dp
 * 문제를 바꿔 이해하면
 * arr2에 저장된 숫자들을 이용해서 N을 만드는 거고 이때 합의 횟수를 최소화하는 것이다. ㅇㅈ?
 * dp배열을 "N을 만들기 위한 최소 덧셈 횟수"로 정의하자
 * 0을 만드는 데에는 0의 횟수가 필요하므로 미리 0으로 저장해둔다.
 * N까지, (i는 arr2에 있는 수)
 * dp[j] = min(dp[j], dp[j-i] + 1)를 수를 수행하면 된다.
 *
 */
